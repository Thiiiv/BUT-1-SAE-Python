#-----Imports-----


from upemtk import *
from random import randint
from time import *
from math import sqrt, atan2, acos, pi, cos, sin
from decimal import getcontext


#-----Fonctions-----


def etiquette(joueur, tour) :
    tag = ''
    if joueur == joueur1 :
        tag = 'j1_'
        return tag + str(tour)
    elif joueur == joueur2 :
        tag = 'j2_'
        return tag + str(tour)
    else :
        tag = 'div_'
        tag1 = 'div_'
        return tag+str(tour), tag1+str(tour+1)  


'''Cette fonction calcule la distance entre 2 centre de cercles'''


def calc_distance(x, y, lst_x, lst_y, joueur) :
    distance = []
    temp = []
    min = 0
    if joueur == joueur1 :
        min = 1
    else :
        min = 0
        
    for i in range(min, len(lst_x), 2) :
        if x >= lst_x[i] and lst_x[i] != 1000**1000 :
            temp.append(x - lst_x[i])
        if x < lst_x[i] and lst_x[i] != 1000**1000 :
            temp.append(lst_x[i] - x)
        if y >= lst_y[i] and lst_y[i] != 1000**1000 :
            temp.append(y - lst_y[i])
        if y < lst_y[i] and lst_y[i] != 1000**1000 :
            temp.append(lst_y[i] - y)
    for j in range(0, len(temp), 2) :
        if j+1 < len(temp) :
            distance.append(sqrt(temp[j]**2 + temp[j+1]**2))
    return distance


def intersection(x, y, lst_x, lst_y, joueur, rayon) :
    min = 0
    if joueur == joueur1 :
        min = 1
    else :
        min = 0

    for i in range(min, len(lst_x), 2) :
        if sqrt((x-lst_x[i])**2+(y-lst_y[i])**2)< rayon*2:
            return i
    return False

def division_boule(x, y, x_proche, y_proche, joueur, tour, tag, lst_rayon) :
    dy = y-y_proche
    dx = x-x_proche
    angle = atan2(dy, dx)
    distance = sqrt(dx**2+dy**2)
    rc1 = lst_rayon[-1] - distance


    if distance < 50 :
        new_x = x + 50 * cos(angle)
        new_y = y + 50 * sin(angle)
        tag3, tag4 = etiquette('', tour)
        efface(tag[-1])
        cercle(x, y, rc1 , 'black', joueur, 1, tag3)
        cercle(new_x, new_y, 50-(50-distance), 'black', joueur, 1, tag4)
        print(new_x, new_y) 
    return


'''Les fonctions j1 et j2 sont des fonctions pour pouvoir attribuer des couleurs froides aléatoirement au joueur1 et des couleurs chaudes aléatoirement au joueur2.'''


def j1():
    lst_col = ["blue", "green", "purple"]
    hazard = randint(0, 2) # Randomizer pour les couleurs
    joueur1 = "black"
    if hazard == 0:
        joueur1 = lst_col[0]
    if hazard == 1:
        joueur1 = lst_col[1]
    if hazard == 2:
        joueur1 = lst_col[2]
    return joueur1


def j2():
    lst_col = ["red", "yellow", "orange"]
    hazard = randint(0, 2)
    joueur2 = "black"
    if hazard == 0:
        joueur2 = lst_col[0]
    if hazard == 1:
        joueur2 = lst_col[1]
    if hazard == 2:
        joueur2 = lst_col[2]
    return joueur2


def calculer_aire(lst_x,lst_y,lst_rayon, joueur):
    SommeAire = 0
    if joueur == joueur1 :
        min = 1
    else :
        min = 0
    for i in range(min, len(lst_x), 2) :
        SommeAire += pi * lst_rayon[i]**2
        if intersection(lst_x[i], lst_y[i], lst_x, lst_y, joueur, rayon) != False:
            j = intersection(lst_x[i], lst_y[i], lst_x, lst_y, joueur, rayon)
            x = lst_x[j]
            y = lst_y[j]
            d = sqrt((x-lst_x[j])**2+(y-lst_y[j])**2)
            #AireIntersection = lst_rayon[i]**2 * acos((d**2 + lst_rayon[i]**2 - lst_rayon[j]**2) / (2 * d * lst_rayon[i])) + lst_rayon[j]**2 * acos((d**2 + lst_rayon[j]**2 - lst_rayon[i]**2) / (2 * d * lst_rayon[j])) -1/2 * sqrt((-d + lst_rayon[i] + lst_rayon[j]) * (d + lst_rayon[i] - lst_rayon[j]) * (d - lst_rayon[i] + lst_rayon[j]) * (d + lst_rayon[i] + lst_rayon[j])) 
            AireIntersection = r**2 * acos((d**2 + r**2 - r**2) / (2 * d * r)) + r**2 * acos((d**2 + r**2 - r**2) / (2 * d * r)) -1/2 * sqrt((-d + r + r) * (d + r - r) * (d - r + r) * (d + r + r)) 
            SommeAire -= AireIntersection

    return SommeAire




def menu_textuel(x1, y1, x2, y2, chaine='', tag='None') :
    """
    Affiche le texte centré par rapport au rectangle.

    :param float x1: ax du rectange
    :param float x2: bx du rectange
    :param float y1: ay du rectange
    :param float y2: by du rectange
    :param str chaine: chaîne de caractère

    """
    dx = x2-x1
    dy = y2-y1
    ancrage = (dx-longueur_texte(chaine))/2
    milieu_y = (dy-hauteur_texte())/2
    texte(x1+ancrage, y1+milieu_y, chaine, 'black', 'nw', 'Purisa', 24, tag)


def start() :
    """
    Affiche le menu de départ pour lancer le jeu ou le quitter lorsque celui-ci est terminé
    """
    largeurFenetre = 800
    hauteurFenetre = 800
    cree_fenetre(largeurFenetre, hauteurFenetre)
    rectangle(0, hauteurFenetre, largeurFenetre, 0, 'black', 'black')
    x_gauche = 10
    x_droite = 400-10
    y_superieur = 200
    y_inferieur = 600
    rectangle(x_gauche, y_superieur, x_droite, y_inferieur, 'grey', 'grey', 1, 'jouer')
    rectangle(x_droite+x_gauche, y_superieur, (x_droite*2), y_inferieur, 'grey', 'grey', 1, 'quitter')
    menu_textuel(x_gauche, y_superieur, x_droite, y_inferieur, 'Jouer')
    menu_textuel(x_droite+x_gauche, y_superieur, x_droite*2, y_inferieur, 'Quitter')
    x, y, z = attente_clic()
    print(x, y)
    if x >= x_gauche and x <= x_droite and y >= y_superieur and y <= y_inferieur :
        efface('jouer')
        mise_a_jour()
        rectangle(x_gauche, y_superieur, x_droite, y_inferieur, 'green', 'green', 1, 'jouer')
        menu_textuel(x_gauche, y_superieur, x_droite, y_inferieur, 'Jouer')
        mise_a_jour()
        sleep(0.5)
        ferme_fenetre()
        Jeu()
        fin()
    if x >= (x_droite+x_gauche) and x <= x_droite*2 and y >= y_superieur and y <= y_inferieur :
        efface('quitter')
        mise_a_jour()
        rectangle(x_droite+x_gauche, y_superieur, (x_droite*2), y_inferieur, 'red', 'red', 1, 'quitter')
        menu_textuel(x_droite+x_gauche, y_superieur, x_droite*2, y_inferieur, 'Quitter')
        mise_a_jour()
        sleep(0.5)
        ferme_fenetre()
    return
    

def fin(n):
    largeurFenetre = 800
    hauteurFenetre = 800
    cree_fenetre(largeurFenetre, hauteurFenetre)
    rectangle(0, hauteurFenetre, largeurFenetre, 0, 'black', 'black')
    x_gauche = 10
    x_droite = 400-10
    y_superieur = 200
    y_inferieur = 600
    rectangle(x_gauche, y_superieur, x_droite, y_inferieur, 'grey', 'grey')
    rectangle(x_droite+x_gauche, y_superieur, (x_droite*2), y_inferieur, 'grey', 'grey')
    
    if n == 0:
        menu_textuel(x_gauche, y_superieur, x_droite, y_inferieur, 'Egalité')
    if n == 1:
        menu_textuel(x_gauche, y_superieur, x_droite, y_inferieur, 'Joueur1 a gagné')
    if n == 2:
        menu_textuel(x_gauche, y_superieur, x_droite, y_inferieur, 'Joueur2 a gagné')

    menu_textuel(x_droite+x_gauche, y_superieur, x_droite*2, y_inferieur, 'Merci d\'avoir joué !')
    attente_clic()
    ferme_fenetre()


'''La fonction Jeu est le squelette de notre code pour le Jeu des Boules elle réutilise les fonctions précédentes pour pouvoir proposé un jeu fonctionnelle.'''


def Jeu():
    cree_fenetre(800, 800)
    lst_x = []
    lst_y = []
    distance1 = []
    distance2 = []
    tag = []
    lst_rayon = []
    
    for i in range(tour) :
        x1, y1, z1 = attente_clic()
        lst_x.append(x1)
        lst_y.append(y1)
        lst_rayon.append(rayon)
        tag.append(etiquette(joueur1, i))
        distance1 = calc_distance(x1, y1, lst_x, lst_y, joueur1)
        print("distance1 :", distance1)
        print()
        menu_textuel(75, 15, 75, 15, 'Tour: J1', 1)
        efface('1')
        if i == 0 :
            cercle(x1, y1, rayon, 'black', joueur1, 1, tag[-1])
        else :
            if intersection(x1, y1, lst_x, lst_y, joueur1, rayon) == False :
                cercle(x1, y1, rayon, 'black', joueur1, 1, tag)
            else :
                division_boule(x1, y1, lst_x, lst_y, distance1, joueur2, lst_rayon)
                lst_x[-1] = 1000**1000
                lst_y[-1] = 1000**1000
        x2, y2, z2 = attente_clic()
        menu_textuel(75, 15, 75, 15, 'Tour: J2', 2)
        efface('2')
        lst_x.append(x2)
        lst_y.append(y2)
        lst_rayon.append(rayon)
        tag.append(etiquette(joueur2, i))
        distance2 = calc_distance(x2, y2, lst_x, lst_y, joueur2)
        print("distance2 :", distance2)
        print()
        if intersection(x2, y2, lst_x, lst_y, joueur2, rayon) == False :
            cercle(x2, y2, rayon, 'black', joueur2, 1, tag[-1])
        else :
            lst_x[-1] = 1000**1000
            lst_y[-1] = 1000**1000
        mise_a_jour()
    
    if calculer_aire(lst_x,lst_y,lst_rayon,joueur1) == calculer_aire(lst_x,lst_y,lst_rayon,joueur2):
        fin(0)
    if calculer_aire(lst_x,lst_y,lst_rayon,joueur1) > calculer_aire(lst_x,lst_y,lst_rayon,joueur2):
        fin(1) #Joueur1 a gagné
    fin(2) #Joueur2 a gagné

    attente_clic()
    ferme_fenetre()


#-----main-----


if __name__ == '__main__':
    joueur1 = j1() # Variables qu'on a besoin de généralisé dans le code
    joueur2 = j2()
    tour = 5
    rayon = 50
    r = rayon
    start()
